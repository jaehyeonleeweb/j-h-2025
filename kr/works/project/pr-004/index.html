<!DOCTYPE html>

  
  


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>열두 장의 꽃 사진에서 열두 개 실루엣의 조합으로 · j-h</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
    <!-- 0) 첫 페인트부터 폴백 감추기 (FOUT/FOIT 방지) -->
    <style>
      html:not(.wf-active):not(.wf-inactive) body { visibility: hidden; }
      html.wf-loading body { visibility: hidden; }
      html.wf-active body,
      html.wf-inactive body { visibility: visible; }
      html.wf-active body { animation: fontFadeIn .18s ease-out; }
      @keyframes fontFadeIn { from { opacity: 0 } to { opacity: 1 } }
    </style>

    <!-- 1) 폰트 커넥션 선연결 -->
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    <link rel="preconnect" href="https://p.typekit.net" crossorigin>

    <!-- 2) Typekit 로더 -->
    <script>
      (function(d) {
        var config = { kitId: 'efe0obd', scriptTimeout: 3000, async: true },
            h = d.documentElement,
            t = setTimeout(function() {
              h.className = h.className.replace(/\bwf-loading\b/g,"") + " wf-inactive";
            }, config.scriptTimeout),
            tk = d.createElement("script"),
            f = false,
            s = d.getElementsByTagName("script")[0],
            a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function() {
          a = this.readyState;
          if (f || (a && a !== "complete" && a !== "loaded")) return;
          f = true; clearTimeout(t);
          try { Typekit.load(config); } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>

    <!-- (선택) 개발 중 편의 -->
    <link rel="stylesheet" href="https://use.typekit.net/efe0obd.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <!-- 전체 2단 그리드 -->
    <div class="shell">
      <!-- 좌측: 세로 메뉴 -->
      <aside class="site-nav">
        <!-- ✅ 모바일 상단 바 (≤600px에서 보이도록 CSS 제어) -->
        <div class="nav-bar" role="navigation" aria-label="mobile top bar">
          <button class="nav-toggle" id="menu-toggle" aria-expanded="false" aria-controls="nav-menu">menu</button>
          
            <a href="&#x2F;works&#x2F;project&#x2F;pr-004&#x2F;" class="lang-toggle">en</a>
          
        </div>

        <!-- ✅ 메인 메뉴: 데스크탑에서 항상 보이고, 모바일에선 토글 대상 -->
        <nav id="nav-menu" aria-label="primary">
          <a href="&#x2F;kr/">all archive</a><br>
          <a href="&#x2F;kr/works/">works</a><br>
          <a href="&#x2F;kr/about/">about</a><br>
          <a href="&#x2F;kr/contact/">contact</a><br>
        
          <!-- ⛔️ 비활성: 링크 대신 span, 클릭 불가, 회색(60%) -->
          <span class="nav-item nav-item--disabled" aria-disabled="true" title="Coming soon">shop</span>
        </nav>

        <!-- ✅ 데스크탑 전용 언어 토글: 메뉴 '아래 한 칸'에 표시 (모바일에선 CSS로 숨김) -->
        <div class="lang-toggle--desktop">
          
            <a href="&#x2F;works&#x2F;project&#x2F;pr-004&#x2F;">en</a>
          
        </div>
      </aside>

      <!-- 우측: 콘텐츠 -->
      <main class="site-main">
        


<article class="page-two-col">
  
  <aside class="page-meta">
    <dl class="meta-list">
      
        <dt><h1>document no.:</h1></dt>
        <dd>14</dd>
      
  
      
        <dt><h1>category:</h1></dt>
        <dd>프로젝트</dd>
      
  
      
        <dt><h1>date:</h1></dt>
        <dd>2025년 11월</dd>
      
  
      
        <dt><h1>format:</h1></dt>
        <dd>책, 134 x 190mm, 254p, 디지털 인쇄</dd>
      
  
      
  
      

      

    </dl>
  </aside>

  <div class="page-body page-content">
    
    <h1 class="display-title">
      열두 장의 꽃 사진에서 열두 개 실루엣의 조합으로
    </h1>
    <p>이 책은 <a href="/kr/thought/th-002/">인터넷(주로 핀터레스트와 인스타그램)을 떠돌아다니던</a> 열두 장의 꽃 사진을 수집해 어도비 일러스트레이터의 <a href="/kr/method/mt-002/">이미지 트레이스</a>  기능의 도움으로 (약간의 변형을 거쳐) 12개의 꽃 실루엣을 생성해 조합한 그래픽들의 작품집이다.
<br><br>
이 실루엣들은 114 x 164 mm 판형의 대지에 배치되고 3가지 층위로 나뉘어, 중첩 효과가 드러날 수 있는 패턴을 부여받는다. 이후 기계적인 단순 조합을 통해 생성된 220개의 그래픽 이미지는 작업 과정과 함께 이 책에 기록된다.
<br><br></p>
<figure class="img--bordered img--fixed" style="max-width:720px;">
  <img src="/media/works/project/pr-004/slideshow_combinations of twelve silhouettes from twelve flower pictures.webp" alt="Main Image">
  <figcaption>Combinations of Twelve Silhouettes from Twelve Flower Pictures (2025)</figcaption>
</figure>
<br>
<p><strong>1. 열두 장의 꽃 사진</strong><br>
인터넷에서 무작위의 꽃 사진을 수집한다. (책의 뒷표지에 기록)
<br><br></p>
<figure class="img--fixed" style="max-width:480px;">
  <img src="/media/works/project/pr-004/combinations of twelve silhouettes from twelve flower pictures-back cover.webp" alt="Back Cover">
  <figcaption>Back Cover</figcaption>
</figure>
<br>
<p><strong>2. 열두 개의 실루엣</strong><br>
앞서 수집한 비트맵 이미지를 이미지 트레이스의 — 나의 의도가 다소 개입된 매개변수의 수치를 포함한 — 지정된 기준에 따라 벡터 그래픽의 실루엣으로 변환한다. 열두 개의 실루엣은 114 x 164 mm 판형의 대지에 배치하여 (a)부터 (l)까지의 태그를 부여한다.
<br><br></p>
<div class="img-grid cols-4" style="max-width:1200px;margin-left:auto;margin-right:auto;"><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 01.webp" alt="Silhouette 1">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 02.webp" alt="Silhouette 2">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 03.webp" alt="Silhouette 3">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 04.webp" alt="Silhouette 4">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 05.webp" alt="Silhouette 5">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 06.webp" alt="Silhouette 6">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 07.webp" alt="Silhouette 7">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 08.webp" alt="Silhouette 8">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 09.webp" alt="Silhouette 9">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 10.webp" alt="Silhouette 10">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 11.webp" alt="Silhouette 11">
</figure><figure class="img--bordered grid-4" data-gridw="1200">
  <img src="/media/works/project/pr-004/twelve silhouette 12.webp" alt="Silhouette 11">
</figure></div>
<br>
<p><strong>3. 열두 개 실루엣의 조합</strong><br>
열두 개의 실루엣을 세 개씩 조합한다. 실루엣이 서로 겹치는 부분이 드러날 수 있도록 세 가지 패턴을 적용하고 미리 짜여진 레이아웃을 기계적인 방식으로 조합한다. 이 과정에서 총 220개의 조합된 결과 이미지가 생성된다.
<br><br></p>
<figure class="img--full img--bordered">
  <img src="/media/works/project/pr-004/combination 001 and 002.webp" alt="Combination #001, #002">
  <figcaption>Combination #001, #002</figcaption>
</figure>
<br>
<p><strong>후기</strong> <br>
이 프로젝트의 뼈대가 된 <strong>수집–추출–조합</strong>이라는 강력한 이미지 제작 방식은 대학생 시절 배운 가장 유용한 방법론 중 하나다. 이 방식을 적용하면 어떤 소재를 출발점으로 삼더라도 새로운 이미지를 얻어낼 수 있다. 수집의 방식, 추출의 방식, 조합의 방식을 개별적으로 생각해보더라도 다양한 변형이 가능하고 이 방식들을 조합하는 경우의 수 또한 무수하다.<sup class="footnote-reference"><a href="#1">1</a></sup> 따라서 출발점이 될 소재의 범위를 아무리 좁게 잡아도 이 프로젝트의 변형버전은 사실상 무한하다.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>이 프로젝트에서 사용된 방식<br>
<strong>수집</strong>: 인터넷에서 다운로드<br>
<strong>추출</strong>: 어도비 일러스트레이터의 이미지 트레이스<br>
<strong>조합</strong>: 114 x 164 mm 판형의 기계적 단순 중첩<br></p>
</div>


    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const content = document.querySelector('.page-content');
        if (!content) return;
      
        /* ---------------------------------------------
         * 1) 흩어진 각주 아이템을 .footnotes 컨테이너로 래핑
         *    - 대상: .footnote-definition, li[id^="fn"]
         *    - 이미 .footnotes가 있으면 건너뜀
         * --------------------------------------------- */
        let wrap = content.querySelector('.footnotes');
        if (!wrap) {
          const items = Array.from(
            content.querySelectorAll('.footnote-definition, li[id^="fn"]')
          );
          if (items.length) {
            const parent = items[0].parentElement;
            const group = items.filter(el => el.parentElement === parent);
            if (group.length) {
              wrap = document.createElement('div');
              wrap.className = 'footnotes';
              wrap.setAttribute('role', 'doc-endnotes');
              wrap.setAttribute('aria-label', 'Footnotes');
              parent.insertBefore(wrap, group[0]);
              group.forEach(el => wrap.appendChild(el));
            }
          }
        }
      
        /* ---------------------------------------------
         * 2) 각주 본문(p) 내 URL을 <a>로 자동 변환
         *    - 호환: http/https/www
         *    - 말미의 쉼표/마침표/괄호 등은 제외
         * --------------------------------------------- */
        if (wrap) {
          const URL_RE = /((?:https?:\/\/|www\.)[^\s<>()]+?)(?=[\s<>()]|$)/g;
      
          wrap.querySelectorAll('.footnote-definition > p, li[id^="fn"] > p')
            .forEach(p => {
              if (p.dataset.autolinked === '1') return;
              p.innerHTML = p.innerHTML.replace(URL_RE, (m, url) => {
                const href = url.startsWith('http') ? url : `https://${url}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
              });
              p.dataset.autolinked = '1';
            });
      
          // 안전: 링크 rel 보정
          wrap.querySelectorAll('a').forEach(a => {
            const rel = (a.getAttribute('rel') || '').split(/\s+/);
            ['noopener','noreferrer'].forEach(tok => { if (!rel.includes(tok)) rel.push(tok); });
            a.setAttribute('rel', rel.join(' ').trim());
          });
        }
      });
      </script>
      
  </div>

</article>


      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <p class="site-footer__text">
        j-h, jaydashaitch, online archive of jae hyeon lee. ©2025 jaehyeon lee
      </p>
      <p class="site-footer__text--mobile">
        j-h, ©2025 jaehyeon lee
      </p>
    </footer>

    <!-- Hangul span 래핑 스크립트 -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const HANGUL_RE = /([\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]+)/g;
        const SKIP_SELECTOR = 'pre, code, kbd, samp, script, style';
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !HANGUL_RE.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
              let p = node.parentNode;
              while (p && p !== document.body) {
                if (p.matches && p.matches(SKIP_SELECTOR)) return NodeFilter.FILTER_REJECT;
                p = p.parentNode;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const texts = [];
        let n;
        while (n = walker.nextNode()) texts.push(n);
        for (const text of texts) {
          const span = document.createElement('span');
          span.innerHTML = text.nodeValue.replace(HANGUL_RE, '<span class="han">$1</span>');
          text.parentNode.replaceChild(span, text);
        }
      });
    </script>

    <!-- ✅ Mobile Menu Script -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("menu-toggle");
        const menu = document.getElementById("nav-menu");
        if (!btn || !menu) return;

        function closeMenu() {
          menu.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
        });

        document.addEventListener("click", (e) => {
          if (!menu.contains(e.target) && !btn.contains(e.target)) closeMenu();
        });

        window.addEventListener("resize", () => {
          if (window.innerWidth > 600) closeMenu();
        });
      });
    </script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__FN_WIRED__) return;
    window.__FN_WIRED__ = true;
  
    /* =========================
       설정값
       ========================= */
    const SCROLL_MS   = 300;   // 부드럽지만 빠르게
    const HL_IN_MS    = 200;   // 페이드 인
    const HL_OUT_MS   = 700;   // 페이드 아웃(느리게)
    const HL_HOLD_MS  = 800;   // 유지 시간(짧게 유지 후 서서히 사라짐)
  
/* =========================
   스크롤 유틸 (컨테이너 대응, quintic S-curve + out-bias)
   ========================= */
   const isScrollable = (el) => {
  if (!el) return false;
  const s = getComputedStyle(el);
  const oy = s.overflowY;
  return (oy === "auto" || oy === "scroll") && el.scrollHeight > el.clientHeight;
};

const getScrollContainer = (el) => {
  let node = el.parentElement;
  while (node && node !== document.body && node !== document.documentElement) {
    if (isScrollable(node)) return node;
    node = node.parentElement;
  }
  return document.scrollingElement || document.documentElement || document.body;
};

/* =========================
   스크롤 애니메이션 (quintic S-curve + out-bias)
   - 부드러운 시작, 끈적한 감속
   ========================= */
const easeInOutSticky = (t) => {
  // Quintic smoothstep (C2 연속, S-curve)
  const t2 = t * t, t3 = t2 * t, t4 = t2 * t2, t5 = t4 * t;
  const base = 6 * t5 - 15 * t4 + 10 * t3; // 기본 S-curve
  const OUT_BIAS = 1.12; // 1.0~1.2 권장 (↑ = 더 끈적한 감속)
  return 1 - Math.pow(1 - base, OUT_BIAS);
};

const scrollToTarget = (container, target, ms = SCROLL_MS, offsetY = 0) =>
  new Promise((resolve) => {
    const containerIsDoc =
      container === document.scrollingElement ||
      container === document.documentElement ||
      container === document.body;

    const containerRect = containerIsDoc
      ? { top: 0 }
      : container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    const start = containerIsDoc
      ? window.pageYOffset || document.documentElement.scrollTop
      : container.scrollTop;

    const targetY = start + (targetRect.top - containerRect.top) + offsetY;

    if (ms <= 0) {
      if (containerIsDoc) window.scrollTo(0, targetY);
      else container.scrollTop = targetY;
      resolve();
      return;
    }

    const startTime = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / ms);
      const eased = easeInOutSticky(t);
      const y = start + (targetY - start) * eased;

      if (containerIsDoc) window.scrollTo(0, y);
      else container.scrollTop = y;

      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        if (containerIsDoc) window.scrollTo(0, targetY);
        else container.scrollTop = targetY;
        resolve();
      }
    };

    requestAnimationFrame(step);
  });

  
    /* =========================
       하이라이트 (빠른 IN → 유지 → 느린 OUT)
       ========================= */
    const highlight = (host, hold = HL_HOLD_MS) => {
      if (!host) return;
      host.classList.add('fn-hl');  // 초기 상태(투명) + 트랜지션 규칙
      // 다음 프레임에 ON
      requestAnimationFrame(() => {
        host.style.setProperty('--fn-hl-in',  `${HL_IN_MS}ms`);
        host.style.setProperty('--fn-hl-out', `${HL_OUT_MS}ms`);
        host.classList.add('is-on');           // 빠르게 켜짐
        setTimeout(() => {
          host.classList.add('is-fading');     // 느리게 꺼짐
          host.classList.remove('is-on');
          setTimeout(() => host.classList.remove('fn-hl', 'is-fading'), HL_OUT_MS + 30);
        }, hold);
      });
    };
  
    /* =========================
       매핑: 본문 참조 ↔ 각주 블록
       ========================= */
    const allIds = new Set([...document.querySelectorAll('[id]')].map(el => el.id));
    const bodyLinks = [...document.querySelectorAll('.page-content a[href^="#"]')]
      .filter(a => !a.closest('.footnote-definition') && !a.closest('.footnotes'));
  
    const footnoteIds = new Set(
      bodyLinks
        .map(a => (a.getAttribute('href') || '').slice(1))
        .filter(id => id && allIds.has(id))
    );
  
    const getFootnoteBlock = (id) => {
      const el = document.getElementById(id);
      return el
        ? (el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el)
        : null;
    };
  
    const backMap = new Map();
    bodyLinks
      .filter(a => footnoteIds.has((a.getAttribute('href') || '').slice(1)))
      .forEach(a => {
        const id = a.getAttribute('href').slice(1);
        const sup = a.closest('sup[id^="fnref"]') || a.closest('sup');
        const target = sup || a;
        if (!target.id) {
          let base = `fnref-auto-${id}`, i = 1, uid = base;
          while (document.getElementById(uid)) uid = `${base}-${i++}`;
          target.id = uid;
        }
        backMap.set(id, target.id);
      });
  
    /* =========================
       이벤트: 본문 → 각주
       ========================= */
    document.addEventListener('click', async (e) => {
      const ref = e.target.closest('.page-content a[href^="#"]');
      if (!ref || ref.closest('.footnote-definition') || ref.closest('.footnotes')) return;
  
      const hash = ref.getAttribute('href') || '';
      if (!hash.startsWith('#')) return;
  
      const id = hash.slice(1);
      if (!footnoteIds.has(id)) return;
  
      e.preventDefault();
      const fnBlock = getFootnoteBlock(id);
      if (!fnBlock) return;
  
      const container = getScrollContainer(fnBlock);
      await scrollToTarget(container, fnBlock, SCROLL_MS, 0);
      history.pushState(null, '', `#${id}`);
      highlight(fnBlock, HL_HOLD_MS);
    });
  
    /* =========================
       이벤트: 각주 → 본문
       ========================= */
    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a');
      if (a) {
        const href = a.getAttribute('href') || '';
        if (href && !href.startsWith('#')) return; // 외부 링크는 방해하지 않음
      }
  
      let node = e.target.closest('[id]');
      while (node) {
        const id = node.id;
        if (footnoteIds.has(id)) {
          const backId = backMap.get(id);
          if (backId) {
            e.preventDefault();
            const backEl = document.getElementById(backId) || document.querySelector(`a[href="#${id}"]`);
            if (!backEl) return;
            const container = getScrollContainer(backEl);
            await scrollToTarget(container, backEl, SCROLL_MS, 0);
            history.pushState(null, '', `#${backId}`);
            highlight(backEl, HL_HOLD_MS);
          }
          return;
        }
        node = node.parentElement;
      }
    });
  
    /* =========================
       해시 진입/변경 시 하이라이트
       ========================= */
    const flashFromHash = async () => {
      const id = location.hash.slice(1);
      if (!id) return;
      const el = document.getElementById(id);
      if (!el) return;
      const target = el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el;
      const container = getScrollContainer(target);
  
      // 뷰포트 안에 대략 보이는지 검사
      const viewTop = (container === document.scrollingElement || container === document.documentElement || container === document.body)
        ? 0
        : container.getBoundingClientRect().top;
      const r = target.getBoundingClientRect();
      const inView = (r.top - viewTop) >= 0 && (r.bottom - viewTop) <= (container.clientHeight || window.innerHeight);
  
      if (!inView) await scrollToTarget(container, target, SCROLL_MS, 0);
      highlight(target, HL_HOLD_MS);
    };
  
    window.addEventListener('hashchange', () => setTimeout(flashFromHash, 30));
    if (location.hash) setTimeout(flashFromHash, 60);
  });
  </script>
  
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.page-content ol > li').forEach(li => {
        // 이미 래퍼가 있으면 생략
        if (li.querySelector(':scope > .li-body')) return;
    
        const body = document.createElement('span'); // inline semantics 유지
        body.className = 'li-body';
    
        // 숫자 마커(::before) 외 모든 노드를 li-body로 이동
        while (li.firstChild) body.appendChild(li.firstChild);
        li.appendChild(body);
      });
    });
    </script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    const currentHost = window.location.hostname;
    const links = document.querySelectorAll('a[href^="http"]');
  
    links.forEach(link => {
      const url = new URL(link.href);
      if (url.hostname !== currentHost) {
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "noopener noreferrer");
      }
    });
  });
  </script>


  
  </body>
</html>
