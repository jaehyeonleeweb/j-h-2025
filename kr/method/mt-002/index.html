<!DOCTYPE html>

  
  


<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>이미지 트레이스 · j-h</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
    <!-- 0) 첫 페인트부터 폴백 감추기 (FOUT/FOIT 방지) -->
    <style>
      html:not(.wf-active):not(.wf-inactive) body { visibility: hidden; }
      html.wf-loading body { visibility: hidden; }
      html.wf-active body,
      html.wf-inactive body { visibility: visible; }
      html.wf-active body { animation: fontFadeIn .18s ease-out; }
      @keyframes fontFadeIn { from { opacity: 0 } to { opacity: 1 } }
    </style>

    <!-- 1) 폰트 커넥션 선연결 -->
    <link rel="preconnect" href="https://use.typekit.net" crossorigin>
    <link rel="preconnect" href="https://p.typekit.net" crossorigin>

    <!-- 2) Typekit 로더 -->
    <script>
      (function(d) {
        var config = { kitId: 'efe0obd', scriptTimeout: 3000, async: true },
            h = d.documentElement,
            t = setTimeout(function() {
              h.className = h.className.replace(/\bwf-loading\b/g,"") + " wf-inactive";
            }, config.scriptTimeout),
            tk = d.createElement("script"),
            f = false,
            s = d.getElementsByTagName("script")[0],
            a;
        h.className += " wf-loading";
        tk.src = "https://use.typekit.net/" + config.kitId + ".js";
        tk.async = true;
        tk.onload = tk.onreadystatechange = function() {
          a = this.readyState;
          if (f || (a && a !== "complete" && a !== "loaded")) return;
          f = true; clearTimeout(t);
          try { Typekit.load(config); } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>

    <!-- (선택) 개발 중 편의 -->
    <link rel="stylesheet" href="https://use.typekit.net/efe0obd.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>

  <body>
    <!-- 전체 2단 그리드 -->
    <div class="shell">
      <!-- 좌측: 세로 메뉴 -->
      <aside class="site-nav">
        <!-- ✅ 모바일 상단 바 (≤600px에서 보이도록 CSS 제어) -->
        <div class="nav-bar" role="navigation" aria-label="mobile top bar">
          <button class="nav-toggle" id="menu-toggle" aria-expanded="false" aria-controls="nav-menu">menu</button>
          
            <a href="&#x2F;method&#x2F;mt-002&#x2F;" class="lang-toggle">en</a>
          
        </div>

        <!-- ✅ 메인 메뉴: 데스크탑에서 항상 보이고, 모바일에선 토글 대상 -->
        <nav id="nav-menu" aria-label="primary">
          <a href="&#x2F;kr/">all archive</a><br>
          <a href="&#x2F;kr/works/">works</a><br>
          <a href="&#x2F;kr/about/">about</a><br>
          <a href="&#x2F;kr/contact/">contact</a><br>
        
          <!-- ⛔️ 비활성: 링크 대신 span, 클릭 불가, 회색(60%) -->
          <span class="nav-item nav-item--disabled" aria-disabled="true" title="Coming soon">shop</span>
        </nav>

        <!-- ✅ 데스크탑 전용 언어 토글: 메뉴 '아래 한 칸'에 표시 (모바일에선 CSS로 숨김) -->
        <div class="lang-toggle--desktop">
          
            <a href="&#x2F;method&#x2F;mt-002&#x2F;">en</a>
          
        </div>
      </aside>

      <!-- 우측: 콘텐츠 -->
      <main class="site-main">
        


<article class="page-two-col">
  
  <aside class="page-meta">
    <dl class="meta-list">
      
        <dt><h1>document no.:</h1></dt>
        <dd>10</dd>
      
  
      
        <dt><h1>category:</h1></dt>
        <dd>방법</dd>
      
  
      
  
      
  
      
  
      

      

    </dl>
  </aside>

  <div class="page-body page-content">
    
    <h1 class="display-title">
      이미지 트레이스
    </h1>
    <p>이미지 트레이스<em>Image Trace</em>는 비트맵 이미지를 벡터로 변환하기 위한 어도비 일러스트레이터의 기능이다. 이 기능은 픽셀 데이터를 분석해서 윤곽선을 베지어 곡선으로 근사한다.<sup class="footnote-reference"><a href="#1">1</a></sup>
<br><br>
이미지 트레이스는 기능의 목적상 언제나 정확한 재현을 목표로 하지만 실제로 그 결과를 정확히 예측하는 것은 불가능하다. 추적된 이미지는 여러 매개변수에 따라 변형되고 세밀한 부분은 언제나 과장되거나 생략된다. 물론 이 결과는 수치에 따라 반복가능하나 여전히 통제가능한 것은 아니다. 계산 과정의 복잡성이 인간의 직관을 넘어서는 한 근사화가 일으키는 디지털 환경의 불규칙한 결과는 항상 예측할 수 없는 것이 된다. 그리고 이미지 트레이스가 필연적으로 수반하는 원본과의 간극은 디지털 이미지의 새로운 가능성—<a href="/kr/thought/th-001/">잠재이미지</a>의 가능성—으로 연결된다.
<br><br>
히토 슈타이얼의 «Strike» (2010)은 간단한 몸짓으로 디지털 무작위성을 드러낸다. 전시장 벽에 걸린 LCD 모니터 화면을 망치로 내리치는 20초 남짓의 영상은 디지털 이미지의 표면과 파편화를 암시한다. 이미지와 정치성을 탐구하는 그의 작가적 경향과 함께 이 작품은 주로 디지털 물질성에서 포착되는 현대 사회의 권력과 저항에 관련한 담론과 연결된다. 하지만 정치적 맥락에 앞서 작품이 내포한 형식적 암시는 꽤나 강렬하다. 디지털 이미지가 가진 고유한(것처럼 보이는) 특성은 과연 예측가능한 것인가? 우연성이 제거된(것처럼 보이는) 알고리즘의 시대에는 불확실한 것과 어떻게 마주칠 수 있는가?
<br><br></p>
<figure class="img--full">
  <img src="/media/method/hito steyerl strike 2010.webp" alt="Strike">
  <figcaption>Strike (2010), Hito Steyerl</figcaption>
</figure>
<hr />
<h3 id="i-bangbeobi-sayongdoen-jageob">이 방법이 사용된 작업:</h3>
<ol>
<li><a href="/kr/works/project/pr-003/">무작위 실루엣</a></li>
<li><a href="/kr/works/project/pr-004/">열두 장의 꽃 사진에서 열두 개 실루엣의 조합으로</a></li>
</ol>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>픽셀을 벡터 이미지로 투사하는 기술은 나름의 긴 역사를 지닌다. 1988년 오토캐드<em>AutoCAD</em>의 내장 기능으로 출시된 캐드 오버레이<em>CAD Overlay</em>와 2001년 오픈소스로 공개된 포트레이스<em>Potrace</em>가 벡터 변환의 대표적 예시이다. 이처럼 레스터 이미지를 벡터화된 도면으로 변환하려는 요구는 오랫동안 존재해왔다. 이미지 트레이스는 1989년 소개된 독립 소프트웨어 어도비 스트림라인<em>Adobe Streamline</em>을 전신으로 한다. 이는 일러스트레이터 CS2에서 라이브 트레이스<em>Live Trace</em>라는 이름으로 통합되었으며, CS6 이후 세부 옵션들의 정비와 이미지 트레이스라는 이름을 얻으며 일러스트레이터의 주요 기능 중 하나가 되었다. 어도비가 독점적 위치를 차지한 오늘날, 이 기능은 우리에게 가장 익숙한 벡터 변환 방식으로 자리잡았다.</p>
</div>


    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const content = document.querySelector('.page-content');
        if (!content) return;
      
        /* ---------------------------------------------
         * 1) 흩어진 각주 아이템을 .footnotes 컨테이너로 래핑
         *    - 대상: .footnote-definition, li[id^="fn"]
         *    - 이미 .footnotes가 있으면 건너뜀
         * --------------------------------------------- */
        let wrap = content.querySelector('.footnotes');
        if (!wrap) {
          const items = Array.from(
            content.querySelectorAll('.footnote-definition, li[id^="fn"]')
          );
          if (items.length) {
            const parent = items[0].parentElement;
            const group = items.filter(el => el.parentElement === parent);
            if (group.length) {
              wrap = document.createElement('div');
              wrap.className = 'footnotes';
              wrap.setAttribute('role', 'doc-endnotes');
              wrap.setAttribute('aria-label', 'Footnotes');
              parent.insertBefore(wrap, group[0]);
              group.forEach(el => wrap.appendChild(el));
            }
          }
        }
      
        /* ---------------------------------------------
         * 2) 각주 본문(p) 내 URL을 <a>로 자동 변환
         *    - 호환: http/https/www
         *    - 말미의 쉼표/마침표/괄호 등은 제외
         * --------------------------------------------- */
        if (wrap) {
          const URL_RE = /((?:https?:\/\/|www\.)[^\s<>()]+?)(?=[\s<>()]|$)/g;
      
          wrap.querySelectorAll('.footnote-definition > p, li[id^="fn"] > p')
            .forEach(p => {
              if (p.dataset.autolinked === '1') return;
              p.innerHTML = p.innerHTML.replace(URL_RE, (m, url) => {
                const href = url.startsWith('http') ? url : `https://${url}`;
                return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
              });
              p.dataset.autolinked = '1';
            });
      
          // 안전: 링크 rel 보정
          wrap.querySelectorAll('a').forEach(a => {
            const rel = (a.getAttribute('rel') || '').split(/\s+/);
            ['noopener','noreferrer'].forEach(tok => { if (!rel.includes(tok)) rel.push(tok); });
            a.setAttribute('rel', rel.join(' ').trim());
          });
        }
      });
      </script>
      
  </div>

</article>


      </main>
    </div>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo" aria-label="site footer">
      <p class="site-footer__text">
        j-h, jaydashaitch, online archive of jae hyeon lee. ©2025 jaehyeon lee
      </p>
      <p class="site-footer__text--mobile">
        j-h, ©2025 jaehyeon lee
      </p>
    </footer>

    <!-- Hangul span 래핑 스크립트 -->
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const HANGUL_RE = /([\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]+)/g;
        const SKIP_SELECTOR = 'pre, code, kbd, samp, script, style';
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !HANGUL_RE.test(node.nodeValue)) return NodeFilter.FILTER_REJECT;
              let p = node.parentNode;
              while (p && p !== document.body) {
                if (p.matches && p.matches(SKIP_SELECTOR)) return NodeFilter.FILTER_REJECT;
                p = p.parentNode;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const texts = [];
        let n;
        while (n = walker.nextNode()) texts.push(n);
        for (const text of texts) {
          const span = document.createElement('span');
          span.innerHTML = text.nodeValue.replace(HANGUL_RE, '<span class="han">$1</span>');
          text.parentNode.replaceChild(span, text);
        }
      });
    </script>

    <!-- ✅ Mobile Menu Script -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("menu-toggle");
        const menu = document.getElementById("nav-menu");
        if (!btn || !menu) return;

        function closeMenu() {
          menu.classList.remove("open");
          btn.setAttribute("aria-expanded", "false");
        }

        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.toggle("open");
          btn.setAttribute("aria-expanded", String(isOpen));
        });

        document.addEventListener("click", (e) => {
          if (!menu.contains(e.target) && !btn.contains(e.target)) closeMenu();
        });

        window.addEventListener("resize", () => {
          if (window.innerWidth > 600) closeMenu();
        });
      });
    </script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__FN_WIRED__) return;
    window.__FN_WIRED__ = true;
  
    /* =========================
       설정값
       ========================= */
    const SCROLL_MS   = 300;   // 부드럽지만 빠르게
    const HL_IN_MS    = 200;   // 페이드 인
    const HL_OUT_MS   = 700;   // 페이드 아웃(느리게)
    const HL_HOLD_MS  = 800;   // 유지 시간(짧게 유지 후 서서히 사라짐)
  
/* =========================
   스크롤 유틸 (컨테이너 대응, quintic S-curve + out-bias)
   ========================= */
   const isScrollable = (el) => {
  if (!el) return false;
  const s = getComputedStyle(el);
  const oy = s.overflowY;
  return (oy === "auto" || oy === "scroll") && el.scrollHeight > el.clientHeight;
};

const getScrollContainer = (el) => {
  let node = el.parentElement;
  while (node && node !== document.body && node !== document.documentElement) {
    if (isScrollable(node)) return node;
    node = node.parentElement;
  }
  return document.scrollingElement || document.documentElement || document.body;
};

/* =========================
   스크롤 애니메이션 (quintic S-curve + out-bias)
   - 부드러운 시작, 끈적한 감속
   ========================= */
const easeInOutSticky = (t) => {
  // Quintic smoothstep (C2 연속, S-curve)
  const t2 = t * t, t3 = t2 * t, t4 = t2 * t2, t5 = t4 * t;
  const base = 6 * t5 - 15 * t4 + 10 * t3; // 기본 S-curve
  const OUT_BIAS = 1.12; // 1.0~1.2 권장 (↑ = 더 끈적한 감속)
  return 1 - Math.pow(1 - base, OUT_BIAS);
};

const scrollToTarget = (container, target, ms = SCROLL_MS, offsetY = 0) =>
  new Promise((resolve) => {
    const containerIsDoc =
      container === document.scrollingElement ||
      container === document.documentElement ||
      container === document.body;

    const containerRect = containerIsDoc
      ? { top: 0 }
      : container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    const start = containerIsDoc
      ? window.pageYOffset || document.documentElement.scrollTop
      : container.scrollTop;

    const targetY = start + (targetRect.top - containerRect.top) + offsetY;

    if (ms <= 0) {
      if (containerIsDoc) window.scrollTo(0, targetY);
      else container.scrollTop = targetY;
      resolve();
      return;
    }

    const startTime = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - startTime) / ms);
      const eased = easeInOutSticky(t);
      const y = start + (targetY - start) * eased;

      if (containerIsDoc) window.scrollTo(0, y);
      else container.scrollTop = y;

      if (t < 1) {
        requestAnimationFrame(step);
      } else {
        if (containerIsDoc) window.scrollTo(0, targetY);
        else container.scrollTop = targetY;
        resolve();
      }
    };

    requestAnimationFrame(step);
  });

  
    /* =========================
       하이라이트 (빠른 IN → 유지 → 느린 OUT)
       ========================= */
    const highlight = (host, hold = HL_HOLD_MS) => {
      if (!host) return;
      host.classList.add('fn-hl');  // 초기 상태(투명) + 트랜지션 규칙
      // 다음 프레임에 ON
      requestAnimationFrame(() => {
        host.style.setProperty('--fn-hl-in',  `${HL_IN_MS}ms`);
        host.style.setProperty('--fn-hl-out', `${HL_OUT_MS}ms`);
        host.classList.add('is-on');           // 빠르게 켜짐
        setTimeout(() => {
          host.classList.add('is-fading');     // 느리게 꺼짐
          host.classList.remove('is-on');
          setTimeout(() => host.classList.remove('fn-hl', 'is-fading'), HL_OUT_MS + 30);
        }, hold);
      });
    };
  
    /* =========================
       매핑: 본문 참조 ↔ 각주 블록
       ========================= */
    const allIds = new Set([...document.querySelectorAll('[id]')].map(el => el.id));
    const bodyLinks = [...document.querySelectorAll('.page-content a[href^="#"]')]
      .filter(a => !a.closest('.footnote-definition') && !a.closest('.footnotes'));
  
    const footnoteIds = new Set(
      bodyLinks
        .map(a => (a.getAttribute('href') || '').slice(1))
        .filter(id => id && allIds.has(id))
    );
  
    const getFootnoteBlock = (id) => {
      const el = document.getElementById(id);
      return el
        ? (el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el)
        : null;
    };
  
    const backMap = new Map();
    bodyLinks
      .filter(a => footnoteIds.has((a.getAttribute('href') || '').slice(1)))
      .forEach(a => {
        const id = a.getAttribute('href').slice(1);
        const sup = a.closest('sup[id^="fnref"]') || a.closest('sup');
        const target = sup || a;
        if (!target.id) {
          let base = `fnref-auto-${id}`, i = 1, uid = base;
          while (document.getElementById(uid)) uid = `${base}-${i++}`;
          target.id = uid;
        }
        backMap.set(id, target.id);
      });
  
    /* =========================
       이벤트: 본문 → 각주
       ========================= */
    document.addEventListener('click', async (e) => {
      const ref = e.target.closest('.page-content a[href^="#"]');
      if (!ref || ref.closest('.footnote-definition') || ref.closest('.footnotes')) return;
  
      const hash = ref.getAttribute('href') || '';
      if (!hash.startsWith('#')) return;
  
      const id = hash.slice(1);
      if (!footnoteIds.has(id)) return;
  
      e.preventDefault();
      const fnBlock = getFootnoteBlock(id);
      if (!fnBlock) return;
  
      const container = getScrollContainer(fnBlock);
      await scrollToTarget(container, fnBlock, SCROLL_MS, 0);
      history.pushState(null, '', `#${id}`);
      highlight(fnBlock, HL_HOLD_MS);
    });
  
    /* =========================
       이벤트: 각주 → 본문
       ========================= */
    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a');
      if (a) {
        const href = a.getAttribute('href') || '';
        if (href && !href.startsWith('#')) return; // 외부 링크는 방해하지 않음
      }
  
      let node = e.target.closest('[id]');
      while (node) {
        const id = node.id;
        if (footnoteIds.has(id)) {
          const backId = backMap.get(id);
          if (backId) {
            e.preventDefault();
            const backEl = document.getElementById(backId) || document.querySelector(`a[href="#${id}"]`);
            if (!backEl) return;
            const container = getScrollContainer(backEl);
            await scrollToTarget(container, backEl, SCROLL_MS, 0);
            history.pushState(null, '', `#${backId}`);
            highlight(backEl, HL_HOLD_MS);
          }
          return;
        }
        node = node.parentElement;
      }
    });
  
    /* =========================
       해시 진입/변경 시 하이라이트
       ========================= */
    const flashFromHash = async () => {
      const id = location.hash.slice(1);
      if (!id) return;
      const el = document.getElementById(id);
      if (!el) return;
      const target = el.closest('.footnote-definition') || el.closest('.footnotes li[id^="fn"]') || el;
      const container = getScrollContainer(target);
  
      // 뷰포트 안에 대략 보이는지 검사
      const viewTop = (container === document.scrollingElement || container === document.documentElement || container === document.body)
        ? 0
        : container.getBoundingClientRect().top;
      const r = target.getBoundingClientRect();
      const inView = (r.top - viewTop) >= 0 && (r.bottom - viewTop) <= (container.clientHeight || window.innerHeight);
  
      if (!inView) await scrollToTarget(container, target, SCROLL_MS, 0);
      highlight(target, HL_HOLD_MS);
    };
  
    window.addEventListener('hashchange', () => setTimeout(flashFromHash, 30));
    if (location.hash) setTimeout(flashFromHash, 60);
  });
  </script>
  
  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.page-content ol > li').forEach(li => {
        // 이미 래퍼가 있으면 생략
        if (li.querySelector(':scope > .li-body')) return;
    
        const body = document.createElement('span'); // inline semantics 유지
        body.className = 'li-body';
    
        // 숫자 마커(::before) 외 모든 노드를 li-body로 이동
        while (li.firstChild) body.appendChild(li.firstChild);
        li.appendChild(body);
      });
    });
    </script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    const currentHost = window.location.hostname;
    const links = document.querySelectorAll('a[href^="http"]');
  
    links.forEach(link => {
      const url = new URL(link.href);
      if (url.hostname !== currentHost) {
        link.setAttribute("target", "_blank");
        link.setAttribute("rel", "noopener noreferrer");
      }
    });
  });
  </script>


  
  </body>
</html>
